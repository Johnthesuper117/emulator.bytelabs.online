<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RETRO TERMINAL GAME ARCHIVE</title>
    <style>
        /* ===== GLOBAL STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #33ff33;
            overflow: hidden;
            height: 100vh;
        }

        /* ===== CRT EFFECT ===== */
        .crt-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #0a0a0a;
            overflow: hidden;
        }

        .crt-container::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        .crt-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 2;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.27861; }
            5% { opacity: 0.34769; }
            10% { opacity: 0.23604; }
            15% { opacity: 0.90626; }
            20% { opacity: 0.18128; }
            25% { opacity: 0.83891; }
            30% { opacity: 0.65583; }
            35% { opacity: 0.67807; }
            40% { opacity: 0.26559; }
            45% { opacity: 0.84693; }
            50% { opacity: 0.96019; }
            55% { opacity: 0.08594; }
            60% { opacity: 0.20313; }
            65% { opacity: 0.71988; }
            70% { opacity: 0.53455; }
            75% { opacity: 0.37288; }
            80% { opacity: 0.71428; }
            85% { opacity: 0.70419; }
            90% { opacity: 0.7003; }
            95% { opacity: 0.36108; }
            100% { opacity: 0.24387; }
        }

        /* ===== TERMINAL WINDOW ===== */
        .terminal {
            position: relative;
            z-index: 3;
            padding: 40px;
            height: 100vh;
            overflow-y: auto;
            text-shadow: 0 0 10px #33ff33;
        }

        .terminal::-webkit-scrollbar {
            width: 10px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: #33ff33;
            box-shadow: 0 0 10px #33ff33;
        }

        /* ===== TEXT STYLES ===== */
        .line {
            margin: 5px 0;
            white-space: pre-wrap;
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: #33ff33;
            animation: blink 1s infinite;
            margin-left: 5px;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        .title {
            font-size: 1.2em;
            margin: 20px 0;
            text-align: center;
        }

        .menu-item {
            margin: 10px 0;
            cursor: pointer;
            padding: 5px;
            transition: all 0.1s;
        }

        .menu-item:hover {
            background: #33ff33;
            color: #0a0a0a;
            box-shadow: 0 0 20px #33ff33;
        }

        .menu-item.selected {
            background: #33ff33;
            color: #0a0a0a;
        }

        /* ===== GAME CANVAS ===== */
        .game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        canvas {
            border: 2px solid #33ff33;
            box-shadow: 0 0 20px #33ff33;
            background: #000;
        }

        .game-info {
            margin: 20px 0;
            text-align: center;
        }

        .game-controls {
            margin: 10px 0;
            text-align: center;
        }

        button {
            background: #0a0a0a;
            color: #33ff33;
            border: 2px solid #33ff33;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            cursor: pointer;
            margin: 5px;
            text-shadow: 0 0 5px #33ff33;
            box-shadow: 0 0 10px #33ff33;
            transition: all 0.2s;
        }

        button:hover {
            background: #33ff33;
            color: #0a0a0a;
            box-shadow: 0 0 20px #33ff33;
        }

        .hidden {
            display: none !important;
        }

        /* ===== FULLSCREEN BUTTON ===== */
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: #0a0a0a;
            color: #33ff33;
            border: 2px solid #33ff33;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            text-shadow: 0 0 5px #33ff33;
            box-shadow: 0 0 10px #33ff33;
        }

        .fullscreen-btn:hover {
            background: #33ff33;
            color: #0a0a0a;
            box-shadow: 0 0 20px #33ff33;
        }

        /* ===== TEXT ADVENTURE ===== */
        .text-adventure {
            max-width: 800px;
            margin: 0 auto;
        }

        .text-input {
            background: #0a0a0a;
            color: #33ff33;
            border: 2px solid #33ff33;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            width: 100%;
            margin-top: 10px;
            text-shadow: 0 0 5px #33ff33;
        }

        .text-input:focus {
            outline: none;
            box-shadow: 0 0 20px #33ff33;
        }
    </style>
</head>
<body>
    <button class="fullscreen-btn" id="fullscreenBtn">FULLSCREEN</button>
    <div class="crt-container">
        <div class="terminal" id="terminal">
            <!-- Content will be dynamically inserted here -->
        </div>
    </div>

    <script>
        /* ===== GLOBAL VARIABLES ===== */
        const terminal = document.getElementById('terminal');
        let currentScreen = 'boot';
        let selectedMenuIndex = 0;
        let currentGame = null;

        /* ===== FULLSCREEN FUNCTIONALITY ===== */
        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        /* ===== PREVENT ARROW KEY SCROLLING ===== */
        window.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        }, false);

        /* ===== UTILITY FUNCTIONS ===== */
        function clearTerminal() {
            terminal.innerHTML = '';
        }

        function typeText(text, delay = 30) {
            return new Promise((resolve) => {
                let i = 0;
                const line = document.createElement('div');
                line.className = 'line';
                terminal.appendChild(line);
                
                const interval = setInterval(() => {
                    if (i < text.length) {
                        line.textContent += text[i];
                        i++;
                        terminal.scrollTop = terminal.scrollHeight;
                    } else {
                        clearInterval(interval);
                        resolve();
                    }
                }, delay);
            });
        }

        function addLine(text) {
            const line = document.createElement('div');
            line.className = 'line';
            line.textContent = text;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        /* ===== BOOT SEQUENCE ===== */
        async function bootSequence() {
            clearTerminal();
            await typeText('RETRO TERMINAL v1.0', 50);
            await typeText('Copyright (c) 1985 RetroSoft Systems', 30);
            addLine('');
            await typeText('Initializing memory... OK', 20);
            await typeText('Loading game archive... OK', 20);
            await typeText('Calibrating CRT display... OK', 20);
            addLine('');
            await typeText('System ready.', 30);
            addLine('');
            setTimeout(showMainMenu, 500);
        }

        /* ===== MAIN MENU ===== */
        function showMainMenu() {
            currentScreen = 'menu';
            clearTerminal();
            
            const ascii = `
    ╔═══════════════════════════════════════════╗
    ║  RETRO TERMINAL GAME ARCHIVE             ║
    ║  ────────────────────────────────────    ║
    ║  Your Portal to Classic Gaming           ║
    ╚═══════════════════════════════════════════╝
            `;
            
            addLine(ascii);
            addLine('');
            addLine('SELECT A GAME:');
            addLine('');
            
            const games = [
                '1. SNAKE - Classic arcade action',
                '2. TETRIS - Puzzle block stacking',
                '3. BREAKOUT - Brick breaking arcade',
                '4. DUNGEON QUEST - Text adventure',
                '5. MEMORY MATCH - Card matching puzzle'
            ];
            
            games.forEach((game, index) => {
                const item = document.createElement('div');
                item.className = 'menu-item';
                item.textContent = game;
                item.onclick = () => selectGame(index);
                terminal.appendChild(item);
            });
            
            addLine('');
            addLine('Use mouse to select or press 1-5 on keyboard');
        }

        /* ===== GAME SELECTION ===== */
        function selectGame(index) {
            switch(index) {
                case 0: startSnake(); break;
                case 1: startTetris(); break;
                case 2: startBreakout(); break;
                case 3: startTextAdventure(); break;
                case 4: startMemoryMatch(); break;
            }
        }

        /* ===== SNAKE GAME ===== */
        function startSnake() {
            currentGame = 'snake';
            clearTerminal();
            
            const container = document.createElement('div');
            container.className = 'game-container';
            container.style.display = 'flex';
            
            const title = document.createElement('div');
            title.className = 'game-info';
            title.innerHTML = '<h2>SNAKE</h2><p>Use arrow keys to move. Eat the food to grow!</p>';
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            canvas.id = 'gameCanvas';
            
            const score = document.createElement('div');
            score.className = 'game-info';
            score.id = 'score';
            score.textContent = 'Score: 0';
            
            const controls = document.createElement('div');
            controls.className = 'game-controls';
            const backBtn = document.createElement('button');
            backBtn.textContent = 'RETURN TO MENU';
            backBtn.onclick = showMainMenu;
            controls.appendChild(backBtn);
            
            container.appendChild(title);
            container.appendChild(canvas);
            container.appendChild(score);
            container.appendChild(controls);
            terminal.appendChild(container);
            
            // Snake game logic
            const ctx = canvas.getContext('2d');
            const gridSize = 20;
            const tileCount = 20;
            
            let snake = [{x: 10, y: 10}];
            let food = {x: 15, y: 15};
            let dx = 0;
            let dy = 0;
            let gameScore = 0;
            let gameLoop;
            
            function drawGame() {
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw snake
                ctx.fillStyle = '#33ff33';
                snake.forEach(segment => {
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                });
                
                // Draw food
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
                
                // Move snake
                if (dx !== 0 || dy !== 0) {
                    const head = {x: snake[0].x + dx, y: snake[0].y + dy};
                    
                    // Check collision with walls
                    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                        clearInterval(gameLoop);
                        alert('Game Over! Score: ' + gameScore);
                        showMainMenu();
                        return;
                    }
                    
                    // Check collision with self
                    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                        clearInterval(gameLoop);
                        alert('Game Over! Score: ' + gameScore);
                        showMainMenu();
                        return;
                    }
                    
                    snake.unshift(head);
                    
                    // Check if food eaten
                    if (head.x === food.x && head.y === food.y) {
                        gameScore += 10;
                        document.getElementById('score').textContent = 'Score: ' + gameScore;
                        food = {
                            x: Math.floor(Math.random() * tileCount),
                            y: Math.floor(Math.random() * tileCount)
                        };
                    } else {
                        snake.pop();
                    }
                }
            }
            
            document.addEventListener('keydown', (e) => {
                if (currentGame !== 'snake') return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (dy === 0) { dx = 0; dy = -1; }
                        break;
                    case 'ArrowDown':
                        if (dy === 0) { dx = 0; dy = 1; }
                        break;
                    case 'ArrowLeft':
                        if (dx === 0) { dx = -1; dy = 0; }
                        break;
                    case 'ArrowRight':
                        if (dx === 0) { dx = 1; dy = 0; }
                        break;
                }
            });
            
            gameLoop = setInterval(drawGame, 100);
        }

        /* ===== TETRIS GAME ===== */
        function startTetris() {
            currentGame = 'tetris';
            clearTerminal();
            
            const container = document.createElement('div');
            container.className = 'game-container';
            container.style.display = 'flex';
            
            const title = document.createElement('div');
            title.className = 'game-info';
            title.innerHTML = '<h2>TETRIS</h2><p>Arrow keys: Move/Rotate. Space: Drop</p>';
            
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 600;
            
            const score = document.createElement('div');
            score.className = 'game-info';
            score.id = 'tetrisScore';
            score.textContent = 'Score: 0';
            
            const controls = document.createElement('div');
            controls.className = 'game-controls';
            const backBtn = document.createElement('button');
            backBtn.textContent = 'RETURN TO MENU';
            backBtn.onclick = showMainMenu;
            controls.appendChild(backBtn);
            
            container.appendChild(title);
            container.appendChild(canvas);
            container.appendChild(score);
            container.appendChild(controls);
            terminal.appendChild(container);
            
            // Tetris game logic
            const ctx = canvas.getContext('2d');
            const rows = 20;
            const cols = 10;
            const blockSize = 30;
            
            const board = Array(rows).fill().map(() => Array(cols).fill(0));
            let gameScore = 0;
            let currentPiece = null;
            let gameLoop;
            
            const pieces = [
                [[1,1,1,1]], // I
                [[1,1],[1,1]], // O
                [[1,1,1],[0,1,0]], // T
                [[1,1,1],[1,0,0]], // L
                [[1,1,1],[0,0,1]], // J
                [[1,1,0],[0,1,1]], // S
                [[0,1,1],[1,1,0]]  // Z
            ];
            
            function newPiece() {
                const piece = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: piece,
                    x: Math.floor(cols / 2) - Math.floor(piece[0].length / 2),
                    y: 0
                };
            }
            
            function drawBoard() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw board
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (board[r][c]) {
                            ctx.fillStyle = '#33ff33';
                            ctx.fillRect(c * blockSize, r * blockSize, blockSize - 1, blockSize - 1);
                        }
                    }
                }
                
                // Draw current piece
                if (currentPiece) {
                    ctx.fillStyle = '#33ff33';
                    currentPiece.shape.forEach((row, r) => {
                        row.forEach((val, c) => {
                            if (val) {
                                ctx.fillRect(
                                    (currentPiece.x + c) * blockSize,
                                    (currentPiece.y + r) * blockSize,
                                    blockSize - 1,
                                    blockSize - 1
                                );
                            }
                        });
                    });
                }
            }
            
            function collision(piece, x, y) {
                for (let r = 0; r < piece.shape.length; r++) {
                    for (let c = 0; c < piece.shape[r].length; c++) {
                        if (piece.shape[r][c]) {
                            const newX = x + c;
                            const newY = y + r;
                            if (newX < 0 || newX >= cols || newY >= rows) return true;
                            if (newY >= 0 && board[newY][newX]) return true;
                        }
                    }
                }
                return false;
            }
            
            function mergePiece() {
                currentPiece.shape.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if (val) {
                            board[currentPiece.y + r][currentPiece.x + c] = 1;
                        }
                    });
                });
            }
            
            function clearLines() {
                for (let r = rows - 1; r >= 0; r--) {
                    if (board[r].every(cell => cell)) {
                        board.splice(r, 1);
                        board.unshift(Array(cols).fill(0));
                        gameScore += 100;
                        document.getElementById('tetrisScore').textContent = 'Score: ' + gameScore;
                        r++;
                    }
                }
            }
            
            function gameStep() {
                if (!currentPiece) {
                    currentPiece = newPiece();
                    if (collision(currentPiece, currentPiece.x, currentPiece.y)) {
                        clearInterval(gameLoop);
                        alert('Game Over! Score: ' + gameScore);
                        showMainMenu();
                        return;
                    }
                }
                
                if (!collision(currentPiece, currentPiece.x, currentPiece.y + 1)) {
                    currentPiece.y++;
                } else {
                    mergePiece();
                    clearLines();
                    currentPiece = null;
                }
                
                drawBoard();
            }
            
            document.addEventListener('keydown', (e) => {
                if (currentGame !== 'tetris' || !currentPiece) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        if (!collision(currentPiece, currentPiece.x - 1, currentPiece.y)) {
                            currentPiece.x--;
                            drawBoard();
                        }
                        break;
                    case 'ArrowRight':
                        if (!collision(currentPiece, currentPiece.x + 1, currentPiece.y)) {
                            currentPiece.x++;
                            drawBoard();
                        }
                        break;
                    case 'ArrowDown':
                        if (!collision(currentPiece, currentPiece.x, currentPiece.y + 1)) {
                            currentPiece.y++;
                            drawBoard();
                        }
                        break;
                    case 'ArrowUp':
                        const rotated = currentPiece.shape[0].map((_, i) =>
                            currentPiece.shape.map(row => row[i]).reverse()
                        );
                        const testPiece = {...currentPiece, shape: rotated};
                        if (!collision(testPiece, currentPiece.x, currentPiece.y)) {
                            currentPiece.shape = rotated;
                            drawBoard();
                        }
                        break;
                    case ' ':
                        while (!collision(currentPiece, currentPiece.x, currentPiece.y + 1)) {
                            currentPiece.y++;
                        }
                        drawBoard();
                        break;
                }
            });
            
            gameLoop = setInterval(gameStep, 500);
        }

        /* ===== BREAKOUT GAME ===== */
        function startBreakout() {
            currentGame = 'breakout';
            clearTerminal();
            
            const container = document.createElement('div');
            container.className = 'game-container';
            container.style.display = 'flex';
            
            const title = document.createElement('div');
            title.className = 'game-info';
            title.innerHTML = '<h2>BREAKOUT</h2><p>Move mouse to control paddle. Break all bricks!</p>';
            
            const canvas = document.createElement('canvas');
            canvas.width = 480;
            canvas.height = 320;
            
            const score = document.createElement('div');
            score.className = 'game-info';
            score.id = 'breakoutScore';
            score.textContent = 'Score: 0';
            
            const controls = document.createElement('div');
            controls.className = 'game-controls';
            const backBtn = document.createElement('button');
            backBtn.textContent = 'RETURN TO MENU';
            backBtn.onclick = showMainMenu;
            controls.appendChild(backBtn);
            
            container.appendChild(title);
            container.appendChild(canvas);
            container.appendChild(score);
            container.appendChild(controls);
            terminal.appendChild(container);
            
            // Breakout game logic
            const ctx = canvas.getContext('2d');
            
            const ball = { x: 240, y: 160, dx: 2, dy: -2, radius: 8 };
            const paddle = { x: 200, y: 300, width: 80, height: 10 };
            const bricks = [];
            const brickRows = 5;
            const brickCols = 8;
            const brickWidth = 55;
            const brickHeight = 15;
            let gameScore = 0;
            let gameLoop;
            
            // Initialize bricks
            for (let r = 0; r < brickRows; r++) {
                for (let c = 0; c < brickCols; c++) {
                    bricks.push({
                        x: c * (brickWidth + 5) + 30,
                        y: r * (brickHeight + 5) + 30,
                        active: true
                    });
                }
            }
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                paddle.x = e.clientX - rect.left - paddle.width / 2;
                paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
            });
            
            function drawGame() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw ball
                ctx.fillStyle = '#33ff33';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw paddle
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
                
                // Draw bricks
                bricks.forEach(brick => {
                    if (brick.active) {
                        ctx.fillRect(brick.x, brick.y, brickWidth, brickHeight);
                    }
                });
                
                // Move ball
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Wall collision
                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                    ball.dx = -ball.dx;
                }
                if (ball.y - ball.radius < 0) {
                    ball.dy = -ball.dy;
                }
                
                // Paddle collision
                if (ball.y + ball.radius > paddle.y &&
                    ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                    ball.dy = -ball.dy;
                }
                
                // Brick collision
                bricks.forEach(brick => {
                    if (brick.active &&
                        ball.x > brick.x && ball.x < brick.x + brickWidth &&
                        ball.y > brick.y && ball.y < brick.y + brickHeight) {
                        ball.dy = -ball.dy;
                        brick.active = false;
                        gameScore += 10;
                        document.getElementById('breakoutScore').textContent = 'Score: ' + gameScore;
                    }
                });
                
                // Game over
                if (ball.y + ball.radius > canvas.height) {
                    clearInterval(gameLoop);
                    alert('Game Over! Score: ' + gameScore);
                    showMainMenu();
                    return;
                }
                
                // Win condition
                if (bricks.every(brick => !brick.active)) {
                    clearInterval(gameLoop);
                    alert('You Win! Score: ' + gameScore);
                    showMainMenu();
                }
            }
            
            gameLoop = setInterval(drawGame, 1000 / 60);
        }

        /* ===== TEXT ADVENTURE ===== */
        function startTextAdventure() {
            currentGame = 'adventure';
            clearTerminal();
            
            const container = document.createElement('div');
            container.className = 'text-adventure';
            
            const output = document.createElement('div');
            output.id = 'adventureOutput';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'text-input';
            input.placeholder = 'Enter command...';
            input.id = 'adventureInput';
            
            const controls = document.createElement('div');
            controls.className = 'game-controls';
            const backBtn = document.createElement('button');
            backBtn.textContent = 'RETURN TO MENU';
            backBtn.onclick = showMainMenu;
            controls.appendChild(backBtn);
            
            container.appendChild(output);
            container.appendChild(input);
            container.appendChild(controls);
            terminal.appendChild(container);
            
            // Adventure game state
            let currentRoom = 'entrance';
            let inventory = [];
            
            const rooms = {
                entrance: {
                    description: 'You stand at the entrance of a dark dungeon. Torches flicker on the walls. There are paths to the NORTH and EAST.',
                    exits: { north: 'hall', east: 'armory' },
                    items: ['torch']
                },
                hall: {
                    description: 'A grand hall with ancient tapestries. Exits are SOUTH and WEST.',
                    exits: { south: 'entrance', west: 'treasury' },
                    items: []
                },
                armory: {
                    description: 'An old armory with rusty weapons. A SWORD catches your eye. Exit is WEST.',
                    exits: { west: 'entrance' },
                    items: ['sword']
                },
                treasury: {
                    description: 'The treasury! Gold coins everywhere and a CROWN on a pedestal. Exit is EAST.',
                    exits: { east: 'hall' },
                    items: ['crown', 'gold']
                }
            };
            
            function displayText(text) {
                const line = document.createElement('div');
                line.className = 'line';
                line.textContent = text;
                output.appendChild(line);
                output.scrollTop = output.scrollHeight;
            }
            
            function processCommand(cmd) {
                cmd = cmd.toLowerCase().trim();
                displayText('> ' + cmd);
                displayText('');
                
                if (cmd === 'look') {
                    displayText(rooms[currentRoom].description);
                    if (rooms[currentRoom].items.length > 0) {
                        displayText('You see: ' + rooms[currentRoom].items.join(', '));
                    }
                } else if (cmd.startsWith('go ')) {
                    const direction = cmd.split(' ')[1];
                    if (rooms[currentRoom].exits[direction]) {
                        currentRoom = rooms[currentRoom].exits[direction];
                        displayText('You move ' + direction + '.');
                        displayText(rooms[currentRoom].description);
                    } else {
                        displayText('You cannot go that way.');
                    }
                } else if (cmd.startsWith('take ')) {
                    const item = cmd.split(' ')[1];
                    const itemIndex = rooms[currentRoom].items.indexOf(item);
                    if (itemIndex > -1) {
                        rooms[currentRoom].items.splice(itemIndex, 1);
                        inventory.push(item);
                        displayText('You take the ' + item + '.');
                    } else {
                        displayText('There is no ' + item + ' here.');
                    }
                } else if (cmd === 'inventory' || cmd === 'i') {
                    if (inventory.length === 0) {
                        displayText('Your inventory is empty.');
                    } else {
                        displayText('You are carrying: ' + inventory.join(', '));
                    }
                } else if (cmd === 'help') {
                    displayText('Commands: LOOK, GO [direction], TAKE [item], INVENTORY, HELP');
                } else if (cmd === 'north' || cmd === 'south' || cmd === 'east' || cmd === 'west') {
                    if (rooms[currentRoom].exits[cmd]) {
                        currentRoom = rooms[currentRoom].exits[cmd];
                        displayText('You move ' + cmd + '.');
                        displayText(rooms[currentRoom].description);
                    } else {
                        displayText('You cannot go that way.');
                    }
                } else {
                    displayText('Unknown command. Type HELP for commands.');
                }
                
                displayText('');
                
                // Win condition
                if (inventory.includes('crown')) {
                    displayText('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    displayText('YOU FOUND THE CROWN! YOU WIN!');
                    displayText('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                }
            }
            
            // Initial text
            displayText('╔══════════════════════════════════════╗');
            displayText('║      DUNGEON QUEST                  ║');
            displayText('║      A Text Adventure               ║');
            displayText('╚══════════════════════════════════════╝');
            displayText('');
            displayText('Your quest: Find the legendary crown!');
            displayText('Type HELP for commands.');
            displayText('');
            displayText(rooms[currentRoom].description);
            displayText('');
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    processCommand(input.value);
                    input.value = '';
                }
            });
            
            input.focus();
        }

        /* ===== MEMORY MATCH GAME ===== */
        function startMemoryMatch() {
            currentGame = 'memory';
            clearTerminal();
            
            const container = document.createElement('div');
            container.className = 'game-container';
            container.style.display = 'flex';
            
            const title = document.createElement('div');
            title.className = 'game-info';
            title.innerHTML = '<h2>MEMORY MATCH</h2><p>Click cards to find matching pairs!</p>';
            
            const canvas = document.createElement('canvas');
            canvas.width = 480;
            canvas.height = 480;
            
            const score = document.createElement('div');
            score.className = 'game-info';
            score.id = 'memoryScore';
            score.textContent = 'Matches: 0 / 8';
            
            const controls = document.createElement('div');
            controls.className = 'game-controls';
            const backBtn = document.createElement('button');
            backBtn.textContent = 'RETURN TO MENU';
            backBtn.onclick = showMainMenu;
            controls.appendChild(backBtn);
            
            container.appendChild(title);
            container.appendChild(canvas);
            container.appendChild(score);
            container.appendChild(controls);
            terminal.appendChild(container);
            
            // Memory game logic
            const ctx = canvas.getContext('2d');
            const cardSize = 100;
            const padding = 20;
            
            const symbols = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const cards = [...symbols, ...symbols].sort(() => Math.random() - 0.5);
            const cardStates = cards.map(() => ({ revealed: false, matched: false }));
            
            let firstCard = null;
            let secondCard = null;
            let matches = 0;
            let canClick = true;
            
            function drawCards() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                cards.forEach((symbol, index) => {
                    const row = Math.floor(index / 4);
                    const col = index % 4;
                    const x = col * (cardSize + padding) + padding;
                    const y = row * (cardSize + padding) + padding;
                    
                    if (cardStates[index].matched) {
                        ctx.fillStyle = '#003300';
                        ctx.fillRect(x, y, cardSize, cardSize);
                    } else if (cardStates[index].revealed) {
                        ctx.fillStyle = '#33ff33';
                        ctx.fillRect(x, y, cardSize, cardSize);
                        ctx.fillStyle = '#000';
                        ctx.font = '48px Courier New';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(symbol, x + cardSize / 2, y + cardSize / 2);
                    } else {
                        ctx.fillStyle = '#33ff33';
                        ctx.fillRect(x, y, cardSize, cardSize);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x + 5, y + 5, cardSize - 10, cardSize - 10);
                    }
                });
            }
            
            canvas.addEventListener('click', (e) => {
                if (!canClick) return;
                
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                const col = Math.floor((clickX - padding) / (cardSize + padding));
                const row = Math.floor((clickY - padding) / (cardSize + padding));
                const index = row * 4 + col;
                
                if (index >= 0 && index < cards.length && 
                    !cardStates[index].revealed && 
                    !cardStates[index].matched) {
                    
                    cardStates[index].revealed = true;
                    drawCards();
                    
                    if (firstCard === null) {
                        firstCard = index;
                    } else if (secondCard === null) {
                        secondCard = index;
                        canClick = false;
                        
                        setTimeout(() => {
                            if (cards[firstCard] === cards[secondCard]) {
                                cardStates[firstCard].matched = true;
                                cardStates[secondCard].matched = true;
                                matches++;
                                document.getElementById('memoryScore').textContent = 'Matches: ' + matches + ' / 8';
                                
                                if (matches === 8) {
                                    alert('Congratulations! You found all matches!');
                                    showMainMenu();
                                }
                            } else {
                                cardStates[firstCard].revealed = false;
                                cardStates[secondCard].revealed = false;
                            }
                            
                            drawCards();
                            firstCard = null;
                            secondCard = null;
                            canClick = true;
                        }, 1000);
                    }
                }
            });
            
            drawCards();
        }

        /* ===== KEYBOARD NAVIGATION ===== */
        document.addEventListener('keydown', (e) => {
            if (currentScreen === 'menu' && e.key >= '1' && e.key <= '5') {
                selectGame(parseInt(e.key) - 1);
            }
        });

        /* ===== START APPLICATION ===== */
        window.addEventListener('load', () => {
            bootSequence();
        });
    </script>
</body>
</html>